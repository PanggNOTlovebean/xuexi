# Redis

### redis干什么？

* 缓存
* 消息队列
* 分布式锁

### 基本数据类型有哪些？

* 字符串： 动态字符串，类似于ArrayList，动态扩容
* 列表： ziplist 多个ziplist
* 哈希：hashtable
* 集合：哈希套壳，value共享同一个
* zset：有序集合，hashtable+跳跃表
* Hyperloglog：基数统计，UV
* Bitmap: 二进制位，用户是否访问
* geospital:经纬度

### redis为什么快？

* 基于内存
* 单线程
* ==IO多路复用==
* ==C语言以及优化(动态字符串)==

### redis是多线程吗？

* 读写命令执行是单线程
* 网络IO、磁盘IO是多线程

### 持久化机制

* RDB(Redis Data Base)
  * 优点：CopyOnWrite对读写性能影响小，占用空间小，恢复速度快
  * 缺点：完整性差
* AOF(Append Only File)
  * 优点：完整性好
  * 缺点：恢复速度慢，同步频繁影响读写性能，占用空间大（rewrite）

### Redis删除策略

* 插入报异常、阻塞
* LRU LFU
* 随机替换key
* 替换快过期的key

### 过期策略

* 定时过期
* 惰性过期
* ==定期过期==

### Redis事务特性

* 单线程带来的隔离性
* 没有隔离级别
* 无原子性

### 并发问题

* Watch 乐观锁
* lua脚本实现原子性操作

### 缓存问题

* 缓存穿透：访问不存在key，
  * 缓存中设置key-null的键值对
  * bitmap白名单  、 布隆过滤器
* 缓存击穿：热点Key过期
  * 永不过期
  * ==设置互斥锁==
* 缓存雪崩：大量key同时过期
  * 均匀过期
  * 永不过期
  * ==设置互斥锁==
  * ==多级缓存==

### Redis部署方式

* 单机
* 主从
* 哨兵
* 集群

### 哨兵的作用

* 监控节点状态
* 选举新的主节点

### 集群如何存放数据

* CRC16哈希成16为然后 %16384 
* 16384个hash slot平摊在所有主节点中

### cluster故障恢复

* 心跳检测机制，定期发送心跳包
* 超过一半认为挂掉，即挂掉
* 选举新的主节点
* 原来挂掉的节点恢复后成为从节点

### 主从同步

* 从机向主机发送同步请求
* 主机发送rbd文件+命令缓冲
* 从机rdb文件代替当前rdb，读入主存
* 此后每次主机更新后发送同步请求
  * 增量复制
  * 全量复制



# JAVA多线程

### 基础概念

* 进程和线程
* 并发和并行
* 同步和异步
* ==饥饿和活锁==
* 死锁的必要条件
  * 互斥
  * 请求和等待
  * 不可剥夺
  * 循环等待
* 守护线程
* 线程状态
  * runnable
  * waited
  * timed waited
  * termanited
  * new

* 线程安全类
  * 包装器类
  * String
  * hashtable vector 全是sychnized实现效率低
  * Collections 都是锁了一个mutex，效率也低
  * JUC
    * ConcurrentHashMap
      * JDK8 只锁表头，所以可以实现并发访问
      * JDK8 sengment数组 分组锁
    * ==ConcurrenctLinkedQueue==
      * ==LinkedBlockedQueue基于CAS无锁实现==
    * ==LinkedBlockedQueue==
      * ==dummy节点==
      * ==支持生产者消费者并行，生产者生产者之间串行，消费者消费者之间穿行==
    * ArrayBlockedQueue
      * 只能一把锁，不用每次new新节点
    * CopyOnWriteArrayList
      * 写时复制，然后覆盖，读写并发，读读并发，写写互斥

###  synchronized

* Monitor
  * waitset
  * ==entrylist==
  * owner

* 对象头
  * mark word
    * hashcode + 001 normal
    * thread + 101 biased
    * 00 lightweight Lock
    * 10 heavyweight Lock
  * class word
  * offset
* 锁机制
  * 偏向锁
    * 重偏向
    * 锁撤销
  * 轻量级锁
    * compare and swap
    * 锁重入
  * 重量级锁
    * 锁自旋
    * 锁消除
* 原子类型
* final变量
  * 声明时加写屏障，保证了可见性，有序性
  * 静态常量在编译时就写死，不会发生任何变化，编译器直接引用，保证了原子性

### volatile

* JMM内存模型
  * 原子性
  * 可见性
  * 有序性
* 写屏障和读屏障
  * 在写操作后加写屏障，之前的指令禁止重排序，写回主存
  * 在读操作前加读屏障，之后的指令禁止重排序，全部读主存

### CAS

* 悲观锁和乐观锁
  * 每次拿到数据都觉得别人会修改，每次都给他上上锁
  * 我不认为别人会修改我的数据，只有在写的时候检查一下是不是被修改了
* 效率问题
  * 无锁并发，减少了阻塞，提升了吞吐量
  * 线程会一直保持运行，吃CPU
* ABA问题
  * 加时间戳来解决
* 实现原理
  * 使用unsafe类做进行底层调用
  * 底层使用cmpxch指令实现原子性

### 线程池

* 为什么使用线程池
  * 线程创建太多不合适
  * 线程来回创建删除也不合适
* 线程池状态
  * running 111
  * shutdown 000
  * stop 001
  * tyding 010
  * terminated 011
* ThreadPoolExcutor线程池构造方法参数
  * 核心线程数
  * 最大线程数
  * 救急线程过期时间
  * 时间单位
  * 阻塞队列
  * 工厂方法为线程命名
  * 阻塞队满时的策略
    * 异常
    * 交给调用者执行
    * LRU
    * 放弃任务
* 创建多少个线程合适
  * CPU密集型 核数+1
  * IO密集型 根据IO阻塞时间来确定

### AQS

* AQS概念

  阻塞式锁和==同步器==框架，可以理解为基于JAVA实现的管程，在此基础上实现自己的锁，可以继承tryacquire,tryrelease,tryacquireshared,tryreleasedshared等方法

* AQS原理

  * state获取状态，==基于CAS改变状态==
  * 共享策略和独占策略
  * 可重入、可打断、==公平非公平==
  * FIFO等待队列，队列里节点包含是线程和状态
  * 条件变量

* AQS的实现类

  * ReentrantLock
    * 支持可重入
    * 支持公平和非公平
    * 原理
      * State描述重入数目
      * head tail维护带dummy的双端队列，状态-1表示有后继需要你去提醒
      * exclusiveOwner指向拥有锁的进程
  * ReentrantReadWriteLock
    * 两个锁读锁和写锁和一个同步器类
    * 读读并发，读写互斥，写写互斥
    * 原理
      * state 高16位读，低16位写
      * 双端队列里Node维护是读还是写
  * StampedLock
    * 读写锁每次都需要通过AQS修改状态，性能依然没有拉满
    * 先读，验证戳来实现读写锁
  * Semaphore
    * PV操作
  * CountdownLatch
    * 线程同步，其他线程把计数置0后启动某任务
    * join得等其他线程结束
  * CyclicBarier
    * 人满发车

* 弱一致性

  * 获取一份拷贝，在拷贝上进行遍历等操作，如果原变量被修改
  * failsave 安全失败 不知道发生了修改，继续遍历
  * failfast 快速失败 抛出异常

### HappensBefore原则

* 内存模型
  * 强内存模型：尽可能易于编程，避免程序员出现错误
  * 弱内存模型：尽可能优化，让程序员来避免错误
* as-if-serial
  * 单线程下，不管怎么指令重排序，执行结果不能改变
  * 多线程下，在正确同步多线程程序的情况下，执行结果一定正确
* happensbefore原则
  * 在不改变程序执行结果的前提下，尽可能的做优化，提高指令并行度

### ThreadLocal

* 线程局部变量
* 每一个thread对象有一个ThreadLocalMap
* ThreadLocalMap以ThreadLocal弱引用为Key，具体的Object为对象
* 每一个线程都会通过threadLocal找到对象的本地副本
* 存在内存泄漏，线程池线程不结束，key销毁但是value没回收，要及时remove

### IO多路复用

* 多进程
* 多线程
* 线程池
* IO多路复用
  * 10万个Socket，线程池都扛不住，使用一个进程来管理多个Socket，事件驱动
  * select poll 
    * select用bitmap存储Socket
    * poll用动态数组来存储
    * 核心态扫一遍所有的Socket，检查是否有事件产生，标记Socket ，用户态下再扫一遍
  * epoll 红黑树来有序存储Socket，将有事件的Socket加入链表给用户态线程

# Mysql

### 三大范式

* 列原子性
* 不存在部分依赖
* 不存在循环依赖

### 索引

* AVL？红黑树？B树？B+树？
  * 非叶子节点不存数据
  * 叶子节点构成有序链表
  * 页内分组二分
* 聚集索引、辅助索引
  * 主键聚集索引，物理顺序和逻辑顺序一致
  * 辅助索引，节点存储的是索引Key和对应的主键
    * 回表，拿到key后要查一遍聚集索引
    * 索引覆盖，辅助索引锁建立的索引项已经包含要查的项，不需要再覆盖
    * 索引下推，在辅助索引找到后进行条件判断，减少回表次数
* 普通索引、唯一索引
  * 普通索引，查找到key后继续往前读，插入可以利用缓存
  * 唯一索引，查找到Key就返回，插入无法利用缓存

* 联合索引
  * 最左前缀匹配
  * 将区分度高的放在最左边
* 什么时候建立索引
  * 避免对频繁更新的建立索引
  * 在频繁排序或分组的列上建索引
  * 在不同值较多的列上建索引
* 哈希索引
  * 不支持多列索引
  * 不支持范围查询
  * 哈希冲突是拉垮
* 索引失效的场景
  * 优化器不想走索引
  * 不满足最左前缀匹配
  * 满足最左但是使用了范围条件
  * 索引字段使用or，如果两个字段都有索引，会走两个索引
  * 使用了函数操作 ！ != not in等运算符
  * like模糊匹配 %在最前面

### 事务

* 事务的特性
  * 原子性
  * 一致性
  * 隔离性
  * 持久性
* 事务并发问题
  * 丢失修改
  * 脏读
  * 不可重复读
  * 幻读
* 事务隔离级别
  * 未提交读：能够读取事务没有提交的数据
  * 提交读：只能读取事务已经提交的数据
  * 可重复读：任意时刻读到的同一批数据是一致的
  * 可串行化：串行执行
* 锁
  * 悲观锁乐观锁
  * 共享锁排他锁
  * 行锁表锁间隙锁临键锁
* ==为什么不使用长事务==
  * 占用锁资源
  * 连接过多
  * ==undolog日志越来越大==
  * ==主从延迟==
  * ==回滚时间长==

### MVCC

* 实现原理
  * readview 判断可见性
  * 版本链 寻找可见版本 
  * undolog
* 快照读和当前读
* RC和RR模式
* 上什么锁
  * 隔离级别
  * 能不能读快照
  * 走不走索引
  * 走当前索引还是二级索引
  * 走二级索引唯一还是不唯一

### 引擎

* Innodb和Myisam的区别
  * B+树和B树
  * 支持事务和不支持事务
  * 支持行锁和不支持行锁
  * 聚集索引和非聚集索引
  * ==MVCC==
  * ==redolog日志==
  * ==外键==
* 查询语句如何执行
  * 连接器连接和鉴权
  * 分析器进行词法分析语法分析
  * 优化器优化语句，选择索引、表的连接顺序等
  * 执行器选择执行计划，权限验证，调用存储引擎
* 更新语句如何执行
  * 连接器-分析器-优化器-执行器
  * bufferpool 缓存，缓存失效后读磁盘加载到缓冲中
  * 写undolog，方便回滚和保留快照
  * 加锁更新缓存中数据
  * 写入redolog buffer
  * redolog 落盘，设置redolog状态为commit prepare
  * binlog 落盘，事务提交 redolog状态改为 commit
  * IO线程出发条件后将bufferpoll里的脏页落盘
* Buffer数据结构
  * Free
  * LRU
  * Flush
* 各种log
  * undolog
    * 逻辑日志
    * 事务回滚
    * MVCC
  * redolog
    * 物理日志
    * 崩溃恢复
    * 四个日志文件循环写，有头指针和尾指针，碰撞后做清空继续写
  * binlog
    * 逻辑日志
    * 用于主从复制和恢复数据
* WAL好处
  * 先写日志再写磁盘
  * 数据库恢复
  * 随机写变成顺序写

### 集群

* 主从复制
  * 主库写入binlog,创建binlog dump线程通知从库进行数据同步
  * 从库IO线程向binlog线程请求一份指定位置开始的log文件，存放再本地relaylog中，再写入binlog，以便知道下次哪里请求开始
  * 从库sql线程实时检测relaylog中是否有新增内容，读relaylog日志，将其解析成SQL语句注意执行
* 并行复制
  * ==为了提高从库读relaylog性能，生产者消费者模式开多个线程回放sql语句==
* 为什么会产生主从同步延迟
  * 从库压力大
  * 从库性能差
  * 大事务执行，产生大binlog，主从同步慢
  * 锁冲突
* 怎么避免主从同步延迟
  * MYSQL并行复制
  * 提高机器性能
  * 避免大事务执行
  * 分担从库压力，主库进行读
  * 分库分表，集群
  * 避免数据库进行大量运算
* 分布式事务
  * 2PC
    * 准备阶段
    * 提交阶段
  * 3PC
    * 增加预提交阶段，防止资源被永久锁定
  * TCC
    * Try:锁资源
    * Confirm：提交
    * Cancel：回退
  * 本地消息表
    * 维护一个消息状态表
  * 消息事务
    * 消息队列
  * 最大努力通知

### FAQ

* 为何选用自增id
  * id过大占用空间
  * 避免聚集索引导致表分裂
  * 聚集索引顺序插入更高效
* SQL语句一直执行慢的原因
  * 没走索引
  * 数据量太大
* SQL语句偶尔执行慢的原因
  * 没拿到锁
  * CPU干别的去了
* 为什么建议VARCHAR不大于255？
  * 节省空间
  * 索引失效
* SQL调优思路
  * 表结构优化
    * 拆分字段
    * 字段类型选择
    * 字段长度限制
    * 增加合理冗余
  * 索引
    * 建立合适索引
    * 利用索引下推、覆盖索引的性质
    * 唯一索引、普通索引的选择
  * 优化查询
    * 避免索引失效
    * 优化条件顺序
    * 小标驱动大表
    * 强迫索引
  * 分库分表
* 为什么不建议使用外键
  * 外键适合单机低并发，保证数据库一致性、完整性，级联操作方便
  * 不适合分布式高并发集群，级联更新会导致阻塞、性能下降，甚至更新风暴

# 网络

### TCPIP五层

* 应用层，直接为用户服务
* 传输层，为两个进程间的提供可靠的通信保证
* 网络层，为两个主机间通信寻找路由，使得数据能够尽快达到主机
* 数据链路层，两个物理最近节点间的通信
* 物理层，01比特流

### 应用层协议

* http
  * get和post的区别
    * 通过url传递，post放在requestbody
    * get 参数暴露在外面
    * get 参数长度有限制
    * get只接受ASCII字符 
    * get 会被浏览器缓存
  * http1.0 和 Http1.1区别
    * 缓存策略
    * 支持长连接
    * 支持range 断点续传
    * host字段
    * 新增状态码，方便传递大文件
  * Http和https区别
    * 增加了ssl/tls协议
    * 增加了ssl/tls协议三次握手过程
    * 需要CA证书
    * 默认端口
  * Http1.1和 http2的区别
    * 1.1基于文本，2基于二进制流
    * 不再传完整的Head，差量更新头部
    * 提供服务端推送功能
    * 实现IO多路复用，多个请求可以在同一个连接并行执行
  * http状态码
    * 1xx,信息
    * 2xx,成功
    * 3xx，重定向
    * 4xx, 客户端错误
    * 5xx，服务器错误
  * 非对称加密 RSA 和证书
    * 服务器生成公私钥，暴露公钥，用私钥加密和解密数据，用户用公钥加密和解密数据
    * 服务器将数据内容哈希后用私钥加密生成签名
    * CA将 服务器的公钥和服务器相关信息用 CA私钥加密，供用户来认证服务器公钥
    * 服务器向用户发送时 包含 数据+签名+证书
* SMTP
  * SMTP发送邮件
  * POP3/IMAP接受邮件
* DNS
  * 服务器划分
    * 本地域名服务器
    * 根域名服务器 .
    * 顶级域名服务器 com cn
    * 二级域名服务器 baidu google
  * 查询方式
    * 递归查询本地域名服务器
    * 迭代查询
  * DNS缓存
    * 浏览器
    * 操作系统
    * 域名服务器
  * TCP？UDP？
    * 大部分是UDP，TCP报文最大长度1500-20-20=1460字节，UDP最大报文512字节，UDP装不下采用TCP
    * 区域传输，主从同步时使用TCP
  * 查询过程
    * 检查浏览器缓存
    * 检查本地缓存
    * 向本地DNS服务器发起递归查询
    * 本地DNS服务器迭代查询根域名、顶级域名、二级域名得到IP地址返回给用户

### 传输层协议

* TCP
  * 三次握手
    * SYN=1 seq=x CLOSED->SYN_SENT
    * SYN=1 ACK=1 seq=y ack=x+1 LISTENING->SYN_RCVD
    * ACK=1 seq=x+1 ack=y+1  SYN_SENT-> ESTABLISHED SYN_RCVD->ESTABLISHED 
  * 为什么需要三次握手
    * 保证通信双方能够建立可靠传输信道的理论最小次数
    * 谢希仁：防止失效的请求经过很久又到达，这时客户端不会返回第三次握手ACK
    * 完成了同步序列号功能
  * 连接队列
    * 半连接队列 :没有完全建立连接的队列
    * 全连接队列：完成三次握手建立连接的队列
  * 四次挥手
    * FIN=1 seq=x  ESTABLIHTED -> FINISH_WAIT1
    * ACK=1 seq=y1+1 ack=x+1 FINISH_WAIT1 -> FINISH_WAIT2 ESTABLISHED->CLOSE_WAIT
    * FIN=1  ACK=1  seq=z ack=x+1 FINISH_WAIT2 -TIME WAIT  CLOSE_WAIT->LASTACK
    * ACK=1 seq=x+1 ack=z+1  等待2MSL TIME_WAIT ->CLOSED LASTACK->CLOSED
  * 等待2MSL
    * 确保远程收到自己的ACK报文
    * 如果又接受到了远程的FIN报文
  * 为什么要四次挥手
    * 任何一方可以主动发起连接释放，待对方确认后进入半关闭状态，待对方没有数据发送后，完全关闭连接
  * TCP重传
    * 超时重传
    * 快速重传
    * SACK
    * DSACK
  * TCP流量控制
    * 防止发送方发的太快，接收方来不及处理
  * TCP拥塞控制
    * 防止网络拥塞，很多包无法及时到达
    * 慢启动，指数增长
    * 拥塞避免，线性增长
    * 拥塞发生
      * 拥塞窗口设置为1
      * 快速重传，/=2
  * 粘包和拆包
    * 发生原因
      * 一次发送数据小于/大于缓冲区剩余，粘包/拆包
      * 接收端没有及时读取缓冲区数据，粘包
      * 发送数据大于最大报文长度，拆包
    * 解决办法
      * 包首部增加字段，标记包长度
      * 每个包固定长度
      * 包与包之间增加边界符号

## 网络层协议

* ARP协议 : I P-MAC地址转换
* NAT协议：局域网内IP地址，到广域网内IP地址转换
* ICMP协议：发送回送请求报文

## FAQ

* URL到返回结果过程
  * 输入网址，浏览器解析内容，生成HTTP消息
  * DNS获取IP地址
  * 调用Socket，与服务器建立TCP连接
  * 委托操作系统协议栈，通过TCP、IP、以太网协议，查询下一跳地址，给数据报封装头部，调用网卡驱动
  * 网卡驱动调用网卡，将二进制信号转化为01电信号发送给最近的路由器
  * 期间经由运营商，由IP协议寻找路由，通过MAC协议找到下一条的物理地址，直到达到Web服务器的接入网路由器中
  * 然后Web服务器防火墙、缓存检查，网口、到驱动、协议栈、SOCKET、进程，收到消息，处理消息，返回结果
  * 浏览器得到返回结果后渲染页面

### JVM

* 对象创建过程
  * 类加载
  * 分配空间
  * 初始化
  * 设置对象头
  * 调用构造方法

* 垃圾回收
  * 空间划分
    * 新生代
    * 老年代
    * 元空间/永久代
  * GC分类
    * 部分收集
      * minor GC
      * major GC
      * mixed GC
    *  完整收集
      * full GC
  * 判断对象死亡
    * 引用计数法
    * 可达性分析
      * GCROOT
  * 判断类无用需同时满足
    * 实例被回收
    * Classloader被回收
    * Class对象被回收
  * 垃圾收集算法
    * 标记-清除算法
    * 标记-复制算法
    * 标记-整理
    * 分代收集算法
  * 类加载过程
    * 加载
      * 通过类名获取二进制字节流
      * 二进制字节流转换为方法区运行时数据结构
      * 创建Class对象，用来访问方法区数据
    * 连接
      * 验证：文件格式、元数据、字节码、符号引用
      * 准备：为类变量进行内存分配、设置默认值
      * 解析：将常量池内的符号引用转化为直接引用
    * 初始化
      * 构造方法
    * 使用
    * 卸载
