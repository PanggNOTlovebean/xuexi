# Introduction

* MIT 6.824
	* parallelism
	* fault tolerance
	* physical
	* security / isolated
* Challenges
	* concurrency
	* partial failure
	* performance
* Infrastructure - Abstraction
	* Storage
	* Communication
	* Computation
* TOPIC
	* Performance
		* 2 times computers -> 2 times throughput 
	* Fault Tolerance
		* Availability
		* Recoverability
		* N-V storage
		* Replication
	* Consistency
		* example : K-V System

# RPC and Threads

* Reason use multi threads
	* I/O concurrency
	* Parallelism
	* Convenient
* Thread challenges
* Coordination
	* channels
	* sync.Cond
	* Wait Group
* Deadlock
* RPC semantic under failures
	* at least once
	* at most once
	* exactly once

# GFS

* CAP

	* performance  -> sharding (分片) 

	* faults  -> tolerance 

	* tolerance -> replication 

	* peplication -> inconsisency

	* consistency -> low performance
* GFS
	* Big & Fast
	* Global
	* Sharding
	* Automatic recovery
	* Single data center
	* Internal use
	* Big sequential access
* MASTER DATA
  * filename  -> array of chunks (nv)
  * handle -> list of chunk servers; version #(nv); primary; lease expiration
  * LOG, CHECKPOINT  in DISK

# VMware-FT	

* Primary-Backup Replication

* Fault tolerance

	* Failures
		* √ fail-stop faults
		* × Bugs

* 两种同步方式

	* State Transfer
		* memory

	* Replicated State Machine
		* op
			* PROBLEMS
				* what state? 复制什么state （paper： all memory & register)
				* Primary/Backup sync
				* Cut-over
				* Anomalies
				* New replicas

* Non-det operations
	* Inputs - packet - data + interrupt
	* weird instructions
	* multi core 
		* 例如不同线程以不同的顺序获得锁
		* paper中是单核的 所以这个paper并不实用
		* 但硬件是在单核VMM之下的 所以是可以在多核硬件下用
	* Log entry (主备之间通过log channel 交互)
		* instruction #
		* type
		* data

* Output Rule
	* 等待backup ACK
	* 发送output
* Duplicated Output
	* 依赖TCP解决
* Test And Set
	* 第三方仲裁
	* 避免脑裂 俩都想成为primary

# GO Thread & Raft

* 为什么使用多线程
	* 多核
	* 表达清晰（定时任务）
	* 阻塞操作
* 多个线程操作共享变量时最好都持有一把锁，因为你想不到编译器会进行怎样的优化

### Raft

* Brain Split
	* 策略1： client 收不到全部确认就不用  那还不如单体
	* 策略2： Client 收到一个就凑合着用 可能会出现脑裂

* Majority vote
	* 2 Of 3 超过所有半数支持 避免了脑裂
	* 2 f + 1  Of  f fault   有2f + 1台服务器 就能够承受f台故障 